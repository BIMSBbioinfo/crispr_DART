---
title: "Downstream Analysis of PiGx-CRISPR outputs"
output: html_document
date: '`r date()`'
params: 
  ampliconName: ''
  indelsFolder: ''
  comparisonsFile: '' 
  workdir: ''
  prefix: ''
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, message = FALSE, warning = FALSE)
knitr::opts_knit$set(root.dir = params$workdir)
library(ggplot2)
library(ggrepel)
library(data.table)
library(plotly)
library(knitr)
library(parallel)
library(pbapply)
```

The goal of this script is to compare indel scores/frequencies between two sample groups in
a case-control setting - and extract important sites that are enriched/depleted in the case 
samples compared to the control samples. 

# Input Settings
```{r printInputSettings}
ampliconName <- params$ampliconName
indelsFolder <- params$indelsFolder
comparisonsFile <- params$comparisonsFile
prefix <- params$prefix
workdir <- params$workdir

inputParameterDesc <- c('Amplicon Name',
                        'indels folder path', 
                        'Table of comparisons to make',
                        'Prefix for output files',
                        'Working directory'
                     )
inputParameterValues <- c(ampliconName, 
                          indelsFolder,
                          comparisonsFile,
                          prefix, 
                          workdir)
inputSettings <- data.frame(parameters = inputParameterDesc,
                            values = inputParameterValues,
                            stringsAsFactors = FALSE)
DT::datatable(data = inputSettings,
              extensions = 'FixedColumns',
              options = list(fixedColumns = TRUE,
                         scrollX = TRUE,
                         pageLength = nrow(inputSettings),
                         dom = 't'))
```

# Comparisons to make 
```{r parse-comparison-table}
comp <- data.table::fread(comparisonsFile)
if(!ampliconName %in% comp$amplicon) {
  stop("There are no comparisons available for amplicon:",ampliconName,
       "in the file:",comparisonsFile,"\n")
}
comp <- comp[amplicon %in% ampliconName]
DT::datatable(data = comp, filter = 'bottom')
```

# Prepare datasets for comparison 
```{r}
#
#import indel/coverage profile stats for samples listed in comparisons
#TODO: allow for multiple case/control samples (comma-separated), currently
#this only supports one case versus one control sample comparison
samples <- unique(c(comp$case_samples, comp$control_samples))
coverageStats <- as.data.table(do.call(rbind, lapply(samples, function(sampleName) {
  f <- file.path(indelsFolder, paste0(sampleName, '.coverageStats.tsv'))
  if(file.exists(f)) {
    dt <- data.table::fread(f)
    return(dt)
  } else {
    stop("Can't open coverageStats.tsv file for sample",sampleName,
            "at",f,"\n")
  }
})))

# sanity check 
summ <- table(coverageStats$sample)
if(min(summ) != max(summ)) {
  print(summ)
  stop("Not all samples in the file",f,"contain the same number of measurements",
       "see: table(coverageStats$sample)")
}

```

# pairwise comparison of samples 
```{r}
#coverageStats: data.frame output from getIndelStats.R function 
comparePerBaseScores <- function(coverageStats, caseSample, controlSample, indelType) {
  case <- coverageStats[sample == caseSample,]
  control <- coverageStats[sample == controlSample,]
  
  #calculate fold-change per base
  caseCov <- case[['cov']]
  caseScore <- case[[indelType]]
  
  controlCov <- control[['cov']]
  controlScore <- control[[indelType]]
  
  A <- ifelse(controlCov > 0, controlScore/controlCov, 0)
  B <- ifelse(caseCov > 0, caseScore/caseCov, 0)
  
  #log fold change as case divided by control
  log2FoldChange <- log2(B/A)
  #percent difference between case and control
  difference <- B - A
  
  #p values  - for each base, compare indel probabilities 
  #and get a fisher exact's p value
  results <- do.call(rbind, lapply(1:length(caseScore), function(i) {
    #contingency matrix
    M <- matrix(c(caseScore[i], controlScore[i], 
                caseCov[i] - caseScore[i], controlCov[i] - controlScore[i]), nrow = 2)
    t <- fisher.test(M)
    oddsRatio <- as.numeric(t$estimate)
    pVal <- t$p.value
    return(data.frame('bp' = i, 'oddsRatio' = oddsRatio, 'pval' = pVal))
  }))
  
  results$padj <- p.adjust(results$pval)
  
  results <- merge(data.frame('bp' = case$bp, 
                        'case' = caseSample, 
                        'control' = controlSample,
                        'caseScore' = caseScore,
                        'caseCov' = caseCov, 
                        'controlScore' = controlScore,
                        'controlCov' = controlCov,
                        'indelType' = indelType,
                        'log2FoldChange' = log2FoldChange, 
                        'difference' = difference), results, by = 'bp')
          
  return(results)
}
```

```{r}

printBedGraphFile <- function(outFile, trackInfo, df) {
  #write bedgraph file
  trackDefinition <- paste0("track type=bedGraph name=",trackInfo)
  writeLines(text = trackDefinition, con = outFile)
  #convert coordinates to 0 based (start, end) form
  df$start <- df$start - 1
  write.table(x = df,
              file = outFile,
              quote = F, sep = '\t', col.names = F, row.names = F, append = T)
}

results <- as.data.frame(do.call(rbind,  lapply(X = comp$comparison, 
                                                           FUN = function(x) {
  r <- do.call(rbind, lapply(c('ins', 'del', 'indel'), function(indelType) {
    comparePerBaseScores(coverageStats = coverageStats, 
                         caseSample = comp[comparison == x,]$case_samples, 
                         controlSample = comp[comparison == x,]$control_samples, 
                         indelType = indelType)
  }))
  r$comparison <- x
  return(r)
})), stringsAsFactors = FALSE)

pdf(file = file.path(workdir, paste0(ampliconName, ".comparisons.plots.pdf")))
plots <- lapply(unique(results$comparison), function(x){
  plots <- lapply(unique(results$indelType), function(indelType) {
    df <- results[results$comparison == x & results$indelType == indelType,]
    
    #segment the profiles and calculate average p-values in each segment
    segments <- as.data.frame(fastseg::fastseg(df$difference))
    segments$mean.padj <- sapply(1:nrow(segments), function(i) {
      mean(df[df$bp >= segments[i, 'start'] & df$bp <= segments[i, 'end'],]$padj)
    })
    #map p-values to stars for visualisation
    segments$label <- gtools::stars.pval(segments$mean.padj)
    
    p <- ggplot(df, aes(x = bp, y = difference)) + 
      geom_point(aes(color = padj < 0.05)) + 
      geom_segment(data = segments, aes(x = start, xend = end, 
                                        y = seg.mean, yend = seg.mean)) + 
      geom_text(data = segments, aes(x = (start+end)/2, y = seg.mean, 
                                     label = label)) + 
      ggtitle(paste0("Case sample: ",unique(as.character(df$case)), 
                     "\nControl sample: ",unique(as.character(df$control))), 
              subtitle = paste0("Indel type: ", indelType)) + 
      theme_bw() 
    print(p)
    
    ## print the 'difference' value for each base position as a bedgraph file
    outfile <- file.path(workdir, paste0(ampliconName, '.comparison.', 
                                         x, '.', indelType,  '.bedgraph'))
    
    df.bg <- data.frame('seqname' = ampliconName, 
                        'start' = df$bp,
                        'end' = df$bp, 
                        'score' = df$difference, stringsAsFactors = FALSE)

    printBedGraphFile(outFile = outfile,
                trackInfo = paste(x, 'per base percent difference', indelType),
                df = df.bg)
    return(p)
  })
  names(plots) <- unique(results$indelType)
  return(plots)
})
names(plots) <- unique(results$comparison)
#close pdf connection
dev.off()

#save stats to file
statsOutFile <- file.path(workdir, paste0(ampliconName, '.comparison.stats.tsv'))
write.table(x = results, file = statsOutFile, quote = FALSE, sep = '\t', row.names = FALSE)
```

## Significantly Affected Base Positions/Segments 

```{r plotIndelProfilesPlots}
out = NULL
for (comparison in names(plots)) {
  out = c(out, knitr::knit_expand(text='### Comparison {{comparison}} {.tabset} \n\n'))
  for (indelType in names(plots[[comparison]])) {
    p <- ggplotly(plots[[comparison]][[indelType]])
    out = c(out, knitr::knit_expand(text='#### {{indelType}} \n\n {{p}} \n\n'))
  }
}
```

`r paste(knit(text = out), collapse = '\n')`

# Comparison of indel frequencies


## Deletion frequencies 

First, get deletions and add coverage values for each deletion
```{r}
samples <- unique(c(comp$case_samples, comp$control_samples))
indels <- as.data.table(do.call(rbind, lapply(samples, function(sampleName) {
  f <- file.path(indelsFolder, paste0(sampleName, '.indels.unfiltered.tsv'))
  if(file.exists(f)) {
    dt <- data.table::fread(f)
    return(dt)
  } else {
    stop("Can't open indels.unfiltere.tsv file for sample",sampleName,
            "at",f,"\n")
  }
})))
#collapse indels
indels <- indels[,length(unique(readID)), by = c('seqname', 'sample', 'start', 'end', 'indelType')]
colnames(indels)[6] <- 'ReadSupport'

deletions <- indels[indelType == 'D']

#get mean coverage at the bases spanned by each deletion 
deletions <- do.call(rbind, lapply(unique(deletions$sample), function(s) {
  dt <- deletions[sample == s]
  
  #make sure the coverage values start from the first base position
  #if not, fill those positions up to first coverage value with zeroes 
  coverage <- coverageStats[sample == s][order(bp)]
  coverage <- c(rep(0, coverage[1,]$bp - 1), 
                coverage$cov)
  
  dt$meanCoverage <- apply(dt, 1, function(x) {
    mean(coverage[x[['start']]:x[['end']]])
  })
  return(dt)
}))
deletions$freq <- deletions$ReadSupport/deletions$meanCoverage
#assign ids for each deletion that represents the coordinates of the deletion
deletions$id <- paste(deletions$seqname, deletions$start, deletions$end, sep = ':')
```

Make plots to compare case versus control samples 
```{r compare_del_freq}
plotSegments <- function(dt) {
  #first randomize the order (to avoid sorting by start position)
  dt <- dt[sample(1:nrow(dt), nrow(dt))]
  dt <- dt[order(end - start)]
  dt$linePos <- 1:nrow(dt)
  ggplot2::ggplot(dt, aes(x = linePos, ymin = start, ymax = end)) + 
    geom_linerange(size = 0.5) + 
    geom_point(data = dt, aes(x = linePos, y = start), size = 1, color = 'red') + 
    geom_point(data = dt, aes(x = linePos, y = end), size = 1, color = 'blue') + 
    theme(axis.text.y = element_blank(), 
          axis.title.y = element_blank(), 
          axis.title.x = element_blank(),
          axis.ticks.y = element_blank(), 
          axis.text.x = element_text(angle = 90), 
          plot.title = element_text(hjust = 0.5), 
          plot.subtitle = element_text(hjust = 0.5)) + 
    coord_flip()
}

dt <- data.table::dcast(deletions, id ~ sample, value.var = 'freq')
dt <- merge(deletions[,c('seqname', 'id', 'start', 'end')], dt,  by = 'id')

plots <- lapply(unique(comp$comparison), function(cmp) {
  caseSample <- comp[comparison == cmp]$case_samples
  controlSample <- comp[comparison == cmp]$control_samples
  #deletions found in both case and control
  shared <- intersect(deletions[sample == caseSample]$id, 
                      deletions[sample == controlSample]$id)
  #make a segment plot of shared deletions 
  dt.shared <- unique(subset(dt[id %in% intersect(deletions[sample == caseSample]$id, 
                                                  deletions[sample == controlSample]$id)], 
                             select = c('id', 'start', 'end', caseSample, controlSample)))
  dt.shared$freqRatio <- dt.shared[,get(caseSample)] / dt.shared[,get(controlSample)]
  p1 <- ggplot(dt.shared) + 
    geom_linerange(aes(x = log2(freqRatio), ymin = start, ymax = end)) +
    geom_point(data = dt.shared, aes(x = log2(freqRatio), y = start), size = 1, color = 'red') + 
    geom_point(data = dt.shared, aes(x = log2(freqRatio), y = end), size = 1, color = 'blue') +
    coord_flip()
  
  #plot deletions found in case but not control
  p2 <- plotSegments(dt = unique(subset(dt[id %in% setdiff(deletions[sample == caseSample]$id, 
                                         deletions[sample == controlSample]$id)], 
                                        select = c('start', 'end', caseSample, controlSample))))
  #plot deletions found in control but not case
  p3 <- plotSegments(dt = unique(subset(dt[id %in% setdiff(deletions[sample == controlSample]$id, 
                                         deletions[sample == caseSample]$id)], 
                                        select = c('start', 'end', caseSample, controlSample))))
  return(list("shared_deletions" = p1, "only_in_case" = p2, "only_in_control" = p3))
})
names(plots) <- unique(comp$comparison)

#Save .tsv files for each sample with frequency values of each deletion
lapply(unique(deletions$sample), function(s) {
  outFile <- file.path(workdir, paste0(ampliconName,".deletionFrequencies.",s,".tsv"))
  write.table(x = deletions[sample == s][order(freq, decreasing = T)], file = outFile, sep = '\t', row.names = FALSE, quote = FALSE)
})
```


```{r plotInsertionDiversity, results='asis', fig.height=8, fig.width=10}
for (comp in names(plots)) {
  cat('### Comparison:',comp,'{.tabset}\n\n')
  for(i in names(plots[[comp]])) {
    cat('#### ',i,'\n\n')
    p <- plots[[comp]][[i]]
    if(!is.null(p)) {
      print(p)
    } else {
      cat("No plot to show\n\n")
    }
    cat("\n\n")
  }
  cat("\n\n")
}
```

```{r sessionInfo}
print(sessionInfo())
```

