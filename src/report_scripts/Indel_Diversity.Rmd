---
title: "Indel Diversity"
output: html_document
params: 
  @PARAMS_TARGET_NAME@: 
---

```{r, child="_settings.Rmd"}
```

Subset sample sheet for those that match the target region of interest
```{r}
targetName <- params$target_name
sampleSheet <- sampleSheet[target_name == targetName]
targetRegion <- as(sampleSheet[target_name == targetName]$target_region[1], 'GRanges')

#get the list of all guides used for the target region 
#get sample-specific cut sites at the target region
sgRNAs <- unlist(strsplit(x = sampleSheet[sampleSheet$target_name == targetName,]$sgRNA_ids, 
                   split = ':'))
cutSites <- cut_sites[cut_sites$name %in% sgRNAs]
```

```{r}
#import deletion coordinates 
deletions <- as.data.table(do.call(rbind, lapply(sampleSheet$sample_name, function(sampleName) {
  f <- file.path(pipeline_output_dir, 'indels', sampleName, paste0(sampleName, '.indels.tsv'))
  if(file.exists(f)) {
    dt <- fread(f)[indelType == 'D']
    dt$sample <- sampleName
    return(dt)
  }
})))

sampleGuides <- lapply(sampleSheet$sample_name, function(s) {
  sgRNAs <- unlist(strsplit(x = sampleSheet[sampleSheet$sample_name == s,]$sgRNA_ids, 
                            split = ':'))
  if(sgRNAs[1] == 'none') {
    sgRNAs <- setdiff(unique(unlist(strsplit(x = sampleSheet[target_name == targetName,]$sgRNA_ids, split = ':'))), 'none')
  }
  return(sgRNAs)
})
names(sampleGuides) <- as.character(sampleSheet$sample_name)

```

```{r}
#find cut sites overlapping with the indels
# indels: a data.table object with minimal columns: start, end, 
# cutSites: a GRanges object of cut site coordinates 
# return: data.frame (nrow = nrow(indels), columns are sgRNA ids, 
#         values are 1 if indel overlaps cutsite, otherwise 0. 
overlapCutSites <- function(indels, cutSites, extend = 5) {
  cutSites <- flank(cutSites, width = extend, both = TRUE)
  query.start <- GenomicRanges::makeGRangesFromDataFrame(indels, start.field = 'start', end.field = 'start')
  query.end <- GenomicRanges::makeGRangesFromDataFrame(indels, start.field = 'end', end.field = 'end')
  
  startOverlaps <- as.data.table(findOverlaps(query.start, flank(cutSites, width = extend, both = TRUE), type = 'any', ignore.strand = TRUE))
  endOverlaps <- as.data.table(findOverlaps(query.end, cutSites, type = 'any', ignore.strand = TRUE))
  
  overlaps <- merge(startOverlaps, endOverlaps, by = c('queryHits', 'subjectHits'), all = TRUE)
  
  M <- matrix(data = rep(0, nrow(indels) * length(cutSites)), 
              nrow = nrow(indels), ncol = length(cutSites))
  colnames(M) <- cutSites$name

  M[as.matrix(overlaps)] <- 1
  
  return(M)
}

#get deletions within the target region
deletions <- as.data.table(subsetByOverlaps(GRanges(deletions), targetRegion, ignore.strand = TRUE))

#define deletion frequency: read support / coverage
deletions$freq <- deletions$ReadSupport/deletions$coverage

#find overlaps with cut sites (only considering guides used in the corresponding sample)
deletionCutsiteOverlaps <- cbind(deletions, overlapCutSites(deletions, cutSites))
deletionCutsiteOverlaps <- do.call(rbind, lapply(unique(deletionCutsiteOverlaps$sample), function(sampleName) {
  dt <- deletionCutsiteOverlaps[sample == sampleName]
  sgRNAs <- sampleGuides[[sampleName]]
  dt$atCutSite <- apply(subset(dt, select = sgRNAs), 1, function(x) sum(x > 0) > 0)
  return(dt)
}))
```

```{r deletion_segment_plots}
# cs: data.frame with cut site coordinates. minimual columns: start, end, name
plotSegments <- function(dt, cs, readSupportThreshold = 0, freqThreshold = 0) {
  dt <- dt[ReadSupport >= readSupportThreshold & freq >= freqThreshold]
  if(nrow(dt) == 0){
    return(NULL)
  }
  #first randomize the order (to avoid sorting by start position)
  dt <- dt[sample(1:nrow(dt), nrow(dt))]
  dt <- dt[order(end - start)]
  dt$linePos <- 1:nrow(dt)
  ggplot2::ggplot(dt, aes(x = linePos, ymin = start, ymax = end)) + 
    geom_linerange(size = 0.5) + 
    labs(title = paste0('unique deletions with > ',readSupportThreshold,
                        ' reads:\n n (all) = ',nrow(dt),
                        '\n n (only at cutsites) = ',nrow(dt[atCutSite == TRUE]))) + 
    geom_point(data = dt, aes(x = linePos, y = start), size = 1, color = 'red') + 
    geom_point(data = dt, aes(x = linePos, y = end), size = 1, color = 'blue') + 
    geom_hline(data = cs, 
              aes(yintercept = start, color = name), show.legend = FALSE) +
    theme(axis.text.y = element_blank(), 
          axis.title.y = element_blank(), 
          axis.ticks.y = element_blank(), 
          axis.text.x = element_text(angle = 90), 
          plot.title = element_text(hjust = 0.5)) + 
    scale_y_continuous(sec.axis = dup_axis(breaks = cs$start,
                                           labels = cs$name)) + 
    coord_flip()
}

plots <- lapply(unique(deletionCutsiteOverlaps$sample), function(s) {
  dt <- deletionCutsiteOverlaps[sample == s]
  if(nrow(dt) == 0) {
    return(NULL)
  }
  #segment plots with varying frequency thresholds
  freqThresholds <- c(0, 0.00001, 0.0001, 0.001, 0.01, 0.1)
  plots <- lapply(freqThresholds, function(t) {
      p <- plotSegments(dt = dt, 
                        cs = as.data.frame(cutSites[cutSites$name %in% sampleGuides[[s]]]), 
                        freqThreshold = t)
      if(!is.null(p)) {
         p <- p + labs(y = paste(targetName, targetRegion))
      }
      return(p)
  })
  names(plots) <- freqThresholds
  return(plots)
})
names(plots) <- unique(deletionCutsiteOverlaps$sample)
```

# Deletion Diversity

## Segment Plots {.tabset .tabset-fade .tabset-pills}

```{r plotDeletionDiversity, results='asis', fig.height=8, fig.width=10}
for (sample in names(plots)) {
  cat('### ',sample,'{.tabset .tabset-fade .tabset-pills}\n\n')
  for(i in names(plots[[sample]])) {
    cat('#### Freq:',i,'\n\n')
    p <- plots[[sample]][[i]]
    if(!is.null(p)) {
      print(p)
    } else {
      cat("No plot to show\n\n")
    }
    cat("\n\n")
  }
  cat("\n\n")
}
```


